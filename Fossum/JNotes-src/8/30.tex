\begin{minipage}[t]{\sw}
\slidenumber
\LARGE
{\bf Continuations} (continued)\exx
Recall that all of these continuations end up
jumping on the trampoline,
carrying out the computations
iteratively instead of recursively.
In particular,
a procedure that makes a tail call
({\em i.e.}, the return value of the procedure
is the value of another procedure application)
discards its own execution context
by passing the tail call value
to the current continuation
instead of saving its current execution context
while evaluating the tail call.
Remember that continuations represent
{\em what should happen now and in the future},
not {\em what has happened in the past}.\exx
For non-tail calls --
for example, the naive recursive implementation
of the factorial function --
there is no way to avoid building nested execution contexts,
since the recursive calls are not in tail position.
The basic principle here is that
{\em evaluating actual parameters
requires creating a nested execution context,
but that calling procedures does not}.\exx
The even/odd mutual recursion example clearly shows that,
without continuations,
relatively small arguments to \verb'even?' result
in stack overflow.
Using continuations,
an application such as \verb'.even?(100000000)'
terminates normally.
Observe that the mutually recursive calls
in the even/odd example are all in tail position.
\end{minipage}
