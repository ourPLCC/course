% finite group operations
% checks for legal properties of a group
elt1(X) :- g(X,Y,Z). % all x such that g(x,y,z) for some y,z
elt2(Y) :- g(X,Y,Z). % all y such that g(x,y,z) for some x,z
elt3(Z) :- g(X,Y,Z). % all z such that g(x,y,z) for some x,y
% all the elements of g
elt(X) :- elt1(X).
elt(Y) :- elt2(Y).
elt(Z) :- elt3(Z).
commute(X,Y) :- g(X,Y,Z), g(Y,X,Z). % X and Y commute
ident(E) :- g(E,E,E). % E is the group identity
inv(X,Y) :- ident(E), g(X,Y,E), g(Y,X,E). % Y is the inverse of X
inv(X) :- inv(X,Y). % all elements that have inverses
non_center(X) :- elt(X), elt(Y), not commute(X,Y). % X is not in the center
center(X) :- elt(X), not non_center(X). % all elements of the center
order2(X) :- ident(E), X != E, g(X,X,E).
order3(X) :- ident(E), X != E, g(X,X,Y), g(X,Y,E).
comm(X,Z) :- elt(Y), inv(Y,YY), g(YY,X,W), g(W,Y,Z). % z=y^(-1) x y
% Y consists of the (cyclic) subgroup generated by X (which should be an atom)
gen(X,Y) :- elt(X), elt(Y), Y=X.
gen(X,Y) :- elt(X), gen(X,Z1), gen(X,Z2), inv(Z1,Z1inv), g(Z1inv, Z2, Y).
% Z consists of the subgroup generated by X and Y (which should be atoms)
gen(X,Y,Z) :- elt(X), elt(Y), elt(Z), Z=X.
gen(X,Y,Z) :- elt(X), elt(Y), elt(Z), Z=Y.
gen(X,Y,Z) :- elt(X), elt(Y), gen(X,Y,Z1), gen(X,Y,Z2), inv(Z1,Z1inv), g(Z1inv, Z2, Z).
% This rule constructs the subgroup generated by atoms g1, g2, ...
% where h is given by facts of the form "h(g1).", "h(g2).", ...
h(Z) :- elt(X), h(X), elt(Y), h(Y), inv(X, Xinv), g(Xinv, Y, Z). 
% Notice that gen(g1,Y)? gives the same values for Y as
%    h(g1).
%    h(Y)?
%
% These rules are used to check the function (x,y) -> z, where g(x,y,z).
ok(X,Y) :- g(X,Y,Z). % all pairs (x,y) such that g(x,y,z)
ck(X,R) :- elt1(X), not elt2(X), R=badx. % every x should be a y
ck(Y,R) :- elt2(Y), not elt1(Y), R=bady. % every y should be an x
ck(Z,R) :- elt3(Z), not elt1(Z), R=badz. % every z should be an x (or y)
ckfn(X,Y,R) :- elt3(Z), g(X,Y,Z), g(X,Y,ZZ), Z!=ZZ, R=badwd. % well-defined
ckfn(X,Y,R) :- elt1(X), elt2(Y), not ok(X,Y), R=baddom. % all (x,y) are covered
% These rules are used to check for g defining a group
ckinv(X,R) :- elt(X), not inv(X), R=badinv. % ck for inverses
ckident(X,R) :- ident(E), g(X,E,Y), Y!=X, R=badident. % ck for right identity
ckident(X,R) :- ident(E), g(E,X,Y), Y!=X, R=badident. % ck for left identity
ckassoc(X,Y,Z,R) :- g(X,Y,T), g(T,Z,U), g(Y,Z,V), g(X,V,W), U!=W, R=badassoc.
% Once the group is loaded, the query ck(R)? should return nothing!
% Otherwise, the value(s) unified with R will describe the ways in which
% g doesn't define a group.
ck(R) :- ck(W,R). % check for bad{x,y,z}
ck(R) :- ckfn(X,Y,R). % check for badwd and baddom
ck(R) :- ckinv(X,R). % check for inverses
ck(R) :- ckident(X,R). % check for behavior of identity
ck(R) :- ckassoc(X,Y,Z,R). % check for associativity
ck(R)?
