\begin{minipage}[t]{\sw}
\slidenumber
\LARGE
{\bf Syntax and semantics} (continued)\exx
A compiler for a language tells you
if a program you write is syntactically correct,
but it's much more difficult to determine
if your program always produces the behavior you want --
that is, if a program is semantically ``correct.''\exx
There are two basic problems:
\begin{enumerate}
\item how to specify formally the behavior you want; and
\item how to translate that specification into a program
  that actually behaves according to the specification.
\end{enumerate}
Of course, a program is its own specification --
it behaves exactly the way its instructions say it should behave.
But because nobody knows exactly how to translate
what a person {\em wants} (a behavioral specification)
into a program that provably {\em behaves} the way the person wants,
programming will always be problematic.
(Behavioral specification is a topic of interest in its own right
and properly belongs in the disciplines
of programming languages and software engineering.
There are some specification languages in use --
Z (pronounced ``Zed'') and CASL are two of them --
but none have proven to be the magic bullet.)\exx
In this course, we are interested
in how a program {\em behaves} -- its semantics.
After all, if {\em you} don't know how a program behaves,
it's hopeless to put that program into a production environment
where users expect it to behave in a certain way.

\end{minipage}
