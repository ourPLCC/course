\begin{minipage}[t]{\sw}
\slidenumber
\LARGE
{\bf Types} (continued)\exx
The following examples show how to annotate a procedure expression
in the \verb'SET' language so that it conforms
to the \verb'TYPE0' language rules
(see Slide 9 for the start of the discussion
of the \verb'TYPE0' language):
\Large
\begin{qv}
% SET language, no type annotations
proc(t) +(t,5)
% the same procedure in the TYPE0 language with type annotations
proc(t:int):int +(t,5)
  % defined type [int=>int], return type int

% SET language, no type annotations
proc(f,x) .f(x)
% the same procedure in the TYPE0 language with type annotations
proc(f:[int=>int], x:int):int .f(x)
  % defined type [[int=>int],int=>int], return type int
\end{qv}
\LARGE
When used in an expression, a procedure {\em application}
is considered to have a type equal
to the {\em return type} of the procedure.
For example, the type
of the following procedure application is \verb'int':
\Large
\begin{qv}
.proc(t:int):int +(t,5) (4) % evaluates to 9, an int
\end{qv}
\LARGE
We will shortly define grammar rules
for the \verb'TYPE0' language that parse expressions
such as these.
\end{minipage}
